<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.36">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>daily-challenge</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="daily-challenge_files/libs/clipboard/clipboard.min.js"></script>
<script src="daily-challenge_files/libs/quarto-html/quarto.js"></script>
<script src="daily-challenge_files/libs/quarto-html/popper.min.js"></script>
<script src="daily-challenge_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="daily-challenge_files/libs/quarto-html/anchor.min.js"></script>
<link href="daily-challenge_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="daily-challenge_files/libs/quarto-html/quarto-syntax-highlighting-01c78b5cd655e4cd89133cf59d535862.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="daily-challenge_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="daily-challenge_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="daily-challenge_files/libs/bootstrap/bootstrap-e19dc0c07aeef78048e587c3f1edba7a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#monday" id="toc-monday" class="nav-link active" data-scroll-target="#monday">Monday</a>
  <ul>
  <li><a href="#life-cycle-of-data-science" id="toc-life-cycle-of-data-science" class="nav-link" data-scroll-target="#life-cycle-of-data-science">Life cycle of data science</a></li>
  <li><a href="#pca" id="toc-pca" class="nav-link" data-scroll-target="#pca">PCA</a></li>
  <li><a href="#linear-regression" id="toc-linear-regression" class="nav-link" data-scroll-target="#linear-regression">Linear regression</a></li>
  <li><a href="#logistic-lasso" id="toc-logistic-lasso" class="nav-link" data-scroll-target="#logistic-lasso">Logistic LASSO</a></li>
  <li><a href="#ica" id="toc-ica" class="nav-link" data-scroll-target="#ica">ICA</a></li>
  <li><a href="#som" id="toc-som" class="nav-link" data-scroll-target="#som">SOM</a></li>
  <li><a href="#umap" id="toc-umap" class="nav-link" data-scroll-target="#umap">UMAP</a></li>
  <li><a href="#diffusion-maps" id="toc-diffusion-maps" class="nav-link" data-scroll-target="#diffusion-maps">Diffusion Maps</a></li>
  </ul></li>
  <li><a href="#tuesday" id="toc-tuesday" class="nav-link" data-scroll-target="#tuesday">Tuesday</a></li>
  <li><a href="#wednesday" id="toc-wednesday" class="nav-link" data-scroll-target="#wednesday">Wednesday</a></li>
  <li><a href="#thursday" id="toc-thursday" class="nav-link" data-scroll-target="#thursday">Thursday</a></li>
  <li><a href="#friday" id="toc-friday" class="nav-link" data-scroll-target="#friday">Friday</a></li>
  </ul>
</nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">daily-challenge</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="monday" class="level2">
<h2 class="anchored" data-anchor-id="monday">Monday</h2>
<section id="life-cycle-of-data-science" class="level3">
<h3 class="anchored" data-anchor-id="life-cycle-of-data-science">Life cycle of data science</h3>
<p>In the obesity data set you detect an outlying age value of 200 and you decide to replace it with median age. Where would this fall in the life cycle of data science? (Multiple choices allowed)</p>
<ul>
<li>collecting data</li>
<li>data cleaning (correct)</li>
<li>data preprocessing (correct)</li>
<li>EDA (argualbly correct)</li>
<li>variable transformations (arguably correct)</li>
<li>feature engineering</li>
</ul>
</section>
<section id="pca" class="level3">
<h3 class="anchored" data-anchor-id="pca">PCA</h3>
<p>PCA’s aim is to reduce the dimensionality of the data while preserving as much variance as possible. Which of the following best describes how PCA achieves this?</p>
<ul>
<li>By selecting the most important original variables based on correlation with the target outcome</li>
<li>By creating new variables (principal components) that are linear combinations of the original variables and ordered by the amount of variance they explain</li>
<li>By removing variables that are highly correlated with each other</li>
<li>By clustering the data into components and selecting the clusters with the largest number of observations</li>
</ul>
<p>Correct:</p>
<ul>
<li>By creating new variables (principal components) that are linear combinations of the original variables and ordered by the amount of variance they explain</li>
</ul>
</section>
<section id="linear-regression" class="level3">
<h3 class="anchored" data-anchor-id="linear-regression">Linear regression</h3>
<div class="cell">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>data_obesity <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"data/data-obesity.csv"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>data_exprs <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"data/data-obesity-genes.csv"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> data_obesity <span class="sc">%&gt;%</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span>bp<span class="fl">.1</span>s, <span class="sc">-</span>bp<span class="fl">.1</span>d, <span class="sc">-</span>bp<span class="fl">.2</span>s, <span class="sc">-</span>bp<span class="fl">.2</span>d) <span class="sc">%&gt;%</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">na.omit</span>() <span class="sc">%&gt;%</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">left_join</span>(data_exprs)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>model <span class="ot">&lt;-</span> <span class="fu">lm</span>(BMI <span class="sc">~</span> LEP <span class="sc">+</span> age <span class="sc">+</span> gender, <span class="at">data =</span> data)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(model)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="do">## Call:</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="do">## lm(formula = BMI ~ LEP + age + gender, data = data)</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="do">## Residuals:</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="do">##      Min       1Q   Median       3Q      Max </span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="do">## -13.9577  -3.7856  -0.3687   2.8617  23.0866 </span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="do">## Coefficients:</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="do">##              Estimate Std. Error t value Pr(&gt;|t|)    </span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="do">## (Intercept) 29.080198   1.017495  28.580  &lt; 2e-16 ***</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="do">## LEP          1.547149   0.292080   5.297 2.04e-07 ***</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="do">## age          0.009291   0.020002   0.465    0.643    </span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="do">## gendermale  -3.114319   0.660175  -4.717 3.41e-06 ***</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="do">## ---</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="do">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="do">## </span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="do">## Residual standard error: 6.219 on 365 degrees of freedom</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="do">## Multiple R-squared:  0.1307, Adjusted R-squared:  0.1235 </span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="do">## F-statistic: 18.29 on 3 and 365 DF,  p-value: 4.462e-11</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Previous studies suggest that the expression of the LEP gene is associated with BMI. You apply a multiple linear regression model to test this association in your dataset, while adjusting for age and gender. Based on the regression output below, which of the following statements are correct? (Multiple answers may be correct)</p>
<ol type="A">
<li>The association between LEP expression and BMI is statistically significant after adjusting for age and gender.</li>
</ol>
<ul>
<li>✅ True – p-value for LEP is very small (2.04e-07).</li>
</ul>
<ol start="2" type="A">
<li>The variable age is significantly associated with BMI in this model.</li>
</ol>
<ul>
<li>❌ False – age has a high p-value (0.643), indicating no significant effect.</li>
</ul>
<ol start="3" type="A">
<li>Male individuals tend to have a lower BMI compared to females, controlling for LEP and age.</li>
</ol>
<ul>
<li>✅ True – gendermale coefficient is negative and significant.</li>
</ul>
<ol start="4" type="A">
<li>The model explains more than half of the variability in BMI.</li>
</ol>
<ul>
<li>❌ False – R-squared is only 0.13 (13%).</li>
</ul>
<ol start="5" type="A">
<li>The coefficient for LEP means that for each unit increase in LEP expression, BMI increases by about 1.55 units, assuming age and gender are constant.</li>
</ol>
<ul>
<li>✅ True – This is exactly what the coefficient represents in multiple regression.</li>
</ul>
</section>
<section id="logistic-lasso" class="level3">
<h3 class="anchored" data-anchor-id="logistic-lasso">Logistic LASSO</h3>
<p>You’re investigating whether obesity status can be predicted from the expression levels of 10 genes of interest: FTO, RNU6-890P, SNORD115-36, MC4R, MTCO3P11, NIPSNAP1, LEP, AFF3, ZYG11A, PTPA</p>
<p>You decide to apply logistic regression with Lasso regularization, using: - a train/test split, - 10-fold cross-validation to select the best penalty parameter (lambda), and - the final model is then fitted on the training set and evaluated on the test set.</p>
<p>Below is the confusion matrix and selected model coefficients:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th></th>
<th>Actual No</th>
<th>Actual Yes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Predicted No</td>
<td>40</td>
<td>2</td>
</tr>
<tr class="even">
<td>Predicted Yes</td>
<td>7</td>
<td>24</td>
</tr>
</tbody>
</table>
<p><br></p>
<p>(Intercept): -1.95<br>
FTO: 1.20<br>
LEP: 0.88<br>
MC4R: -0.44<br>
ZYG11A: 0.56</p>
<p>(All other genes have coefficient = 0)</p>
<ol type="A">
<li>The model correctly identifies more non-obese than obese individuals.</li>
</ol>
<ul>
<li>✅ True — The confusion matrix shows 40 true negatives (No) vs 24 true positives (Yes), so more non-obese individuals were correctly classified.</li>
</ul>
<ol start="2" type="A">
<li>Genes with positive coefficients increase the odds of being obese.</li>
</ol>
<ul>
<li>✅ True — In logistic regression, a positive coefficient implies an increase in the log-odds (and thus odds) of the outcome (obesity = “Yes”).</li>
</ul>
<ol start="3" type="A">
<li>The gene MC4R is positively associated with obesity.</li>
</ol>
<ul>
<li>❌ False — MC4R has a negative coefficient (-0.44), meaning higher expression is associated with lower odds of being obese.</li>
</ul>
<ol start="4" type="A">
<li>Lasso has excluded some genes from the model.</li>
</ol>
<ul>
<li>✅ True — Only 4 of the 10 genes have non-zero coefficients, indicating Lasso set the rest to zero (excluded them).</li>
</ul>
<ol start="5" type="A">
<li>The model perfectly classifies all individuals in the test set.</li>
</ol>
<ul>
<li>❌ False — The confusion matrix shows errors: 7 false positives and 2 false negatives.</li>
</ul>
<ol start="6" type="A">
<li>Lasso improves interpretability by selecting only relevant genes.</li>
</ol>
<ul>
<li>✅ True — Lasso’s strength is variable selection, simplifying the model by retaining only the most informative features.</li>
</ul>
</section>
<section id="ica" class="level3">
<h3 class="anchored" data-anchor-id="ica">ICA</h3>
<p>One of the main goals of Independent Component Analysis (ICA) is to uncover hidden source signals from observed mixtures. Which of the following best describes how ICA achieves this, and how it differs from PCA?</p>
<ul>
<li>ICA finds new variables that are linear combinations of the original features, ordered by the variance they explain, and uncorrelated with each other.</li>
<li>ICA clusters the original variables into independent groups based on their mutual distance and variance.</li>
<li>ICA transforms the data into a new set of components that are as statistically independent as possible, and is particularly suited for non-Gaussian data.</li>
<li>ICA standardizes the data and uses a rotation matrix to align components with maximum class separability</li>
</ul>
<p>(correct)</p>
<ul>
<li>ICA transforms the data into a new set of components that are as statistically independent as possible, and is particularly suited for non-Gaussian data.</li>
</ul>
</section>
<section id="som" class="level3">
<h3 class="anchored" data-anchor-id="som">SOM</h3>
<p>During the training of a Self-Organizing Map, what happens when an input vector is presented to the network?</p>
<ol type="A">
<li>All nodes in the map are updated equally to resemble the input vector</li>
<li>Only the node with the closest weight vector (Best Matching Unit) is updated to match the input vector</li>
<li>The Best Matching Unit and its neighboring nodes are adjusted to become more similar to the input vector</li>
<li>The input vector is discarded if it doesn’t match any existing node exactly</li>
</ol>
<p>Answer: C) The Best Matching Unit and its neighboring nodes are adjusted to become more similar to the input vector</p>
<p>Explanation:</p>
<p>When an input vector is introduced, the SOM identifies the Best Matching Unit (BMU)—the node whose weight vector is most similar to the input. The BMU and its neighboring nodes are then updated to more closely resemble the input vector. This neighborhood updating helps preserve the topological structure of the data on the map.</p>
</section>
<section id="umap" class="level3">
<h3 class="anchored" data-anchor-id="umap">UMAP</h3>
<p>UMAP (Uniform Manifold Approximation and Projection) is a nonlinear dimensionality reduction technique. Which of the following best describes how UMAP constructs its low-dimensional embedding?</p>
<ol type="A">
<li>By preserving pairwise Euclidean distances between all data points in the high-dimensional space.</li>
<li>By identifying clusters in the data using k-means and projecting cluster centers to a lower-dimensional space.</li>
<li>By constructing a fuzzy topological representation of the high-dimensional data and optimizing a low-dimensional graph to preserve this structure.</li>
<li>By performing linear projections that maximize the variance captured in the first few components.</li>
</ol>
<p>Correct Answer: C) By constructing a fuzzy topological representation of the high-dimensional data and optimizing a low-dimensional graph to preserve this structure.</p>
<p>Explanation:</p>
<p>UMAP operates by modeling the high-dimensional data as a fuzzy topological structure, capturing both local and global relationships. It then seeks a low-dimensional embedding that best preserves this structure, ensuring that the manifold’s topology is maintained in the reduced space. This approach allows UMAP to effectively capture complex data patterns that linear methods might miss.</p>
</section>
<section id="diffusion-maps" class="level3">
<h3 class="anchored" data-anchor-id="diffusion-maps">Diffusion Maps</h3>
<p>You are analyzing high-dimensional gene expression data and decide to apply Diffusion Maps for dimensionality reduction. After constructing the kernel matrix using a Gaussian kernel and computing the Markov transition matrix P, you raise P to the power t to simulate diffusion over time. Finally, you perform eigen decomposition on P to obtain the diffusion components.</p>
<p>Which of the following statements about Diffusion Maps are true? (Select all that apply)</p>
<ol type="A">
<li>The kernel matrix K measures similarity between data points, with larger values indicating greater similarity.</li>
<li>The Markov transition matrix P is obtained by normalizing K so that each row sums to 1, representing transition probabilities.</li>
<li>Raising P to the power t allows the model to capture local structures in the data more effectively.</li>
<li>Eigen decomposition of P yields eigenvectors and eigenvalues that are used to embed the data into a lower-dimensional space, capturing the main diffusion directions.</li>
<li>The first non-trivial diffusion component (DC1) often captures the global structure of the data, such as developmental trajectories.</li>
</ol>
<p>Explanation:</p>
<ol type="A">
<li>Correct. The kernel matrix K quantifies the similarity between data points, with larger values indicating higher similarity.</li>
<li>Correct. The transition matrix P is derived by normalizing K so that each row sums to 1, converting similarities into transition probabilities.</li>
<li>Incorrect. Raising P to the power t allows the model to capture global structures by simulating diffusion over multiple steps, not just local structures.</li>
<li>Correct. Eigen decomposition of P provides eigenvectors and eigenvalues that are used to embed the data into a lower-dimensional space, highlighting the main directions of diffusion.</li>
<li>Correct. The first non-trivial diffusion component (DC1) often captures the most significant global structure in the data, such as continuous developmental processes.</li>
</ol>
</section>
</section>
<section id="tuesday" class="level2">
<h2 class="anchored" data-anchor-id="tuesday">Tuesday</h2>
</section>
<section id="wednesday" class="level2">
<h2 class="anchored" data-anchor-id="wednesday">Wednesday</h2>
</section>
<section id="thursday" class="level2">
<h2 class="anchored" data-anchor-id="thursday">Thursday</h2>
</section>
<section id="friday" class="level2">
<h2 class="anchored" data-anchor-id="friday">Friday</h2>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>