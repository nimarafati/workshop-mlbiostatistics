{
  "hash": "ce7479bca754bac6a7cc53abe0a7c424",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"ICA\"\nformat:\n  html:\n    toc: true\n    toc-location: right\n    number-sections: true\n    code-fold: false\n    sidebar: true\neditor: visual\neditor_options: \n  chunk_output_type: console\nknitr:\n  opts_chunk: \n    message: false\n    warning: false\n    code-fold: false\n    include: true\n    collapse: true\n    eval: true\n    fig.show: hold\n---\n\n\n\n\n## Introduction\n\nIndependent Component Analysis (ICA) is an unsupervised method that separates multivariate data into statistically independent signals, often used to uncover hidden biological processes. In this tutorial, you'll learn how to apply ICA to gene expression data and interpret both sample structure and gene-level drivers.\n\nTutorial is based on [https://payamemami.com/ica_basics/](https://payamemami.com/ica_basics/), a document with more detailed introduction to the methods, including its mathematical foundations.\n\n## Data\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# adjust data simulation code to include some gene names for the main categories\n\n# Load necessary library\nlibrary(tidyverse)\nlibrary(fastICA)\n\n# Set parameters\nset.seed(123)\nn_cells <- 2000\nn_sources <- 3\nn_clusters <- 5\ncells_per_cluster <- n_cells / n_clusters\n\n# Define gene sets\nimmune_genes <- c(\"CD3D\", \"CD4\", \"CD8A\", \"IFNG\", \"IL2\", \"PTPRC\", \"GZMB\", \"LCK\", \"CCR7\", \"HLA-DRA\")\nmetabolism_genes <- c(\"HK2\", \"LDHA\", \"PKM\", \"G6PD\", \"ACLY\", \"IDH1\", \"PGK1\", \"CPT1A\", \"FASN\", \"ACACA\")\ncell_cycle_genes <- c(\"CDK1\", \"CCNB1\", \"MKI67\", \"PCNA\", \"TOP2A\", \"BUB1\", \"CDC20\", \"PLK1\", \"AURKB\", \"CENPA\")\n\ndb_genes <- data.frame(\n  gene = c(immune_genes, metabolism_genes, cell_cycle_genes),\n  category = c(rep(\"Immune\", length(immune_genes)),\n               rep(\"Metabolism\", length(metabolism_genes)),\n               rep(\"Cell Cycle\", length(cell_cycle_genes)))\n)\n\n# Fill up to 1000 genes with generic names\nother_genes <- paste0(\"GENE\", 1:(1000 - length(immune_genes) - length(metabolism_genes) - length(cell_cycle_genes)))\ngene_names <- c(immune_genes, metabolism_genes, cell_cycle_genes, other_genes)\nn_genes <- length(gene_names)\n\n# Define cluster-specific means for latent sources (immune, metabolism)\ncluster_means <- matrix(c(\n  3.0, 0.5,   # Cluster 1: High immune, low metabolism\n  0.1, 2.0,   # Cluster 2: Low immune, high metabolism\n  1.5, 1.5,   # Cluster 3: Moderate all\n  3.0, 2.5,   # Cluster 4: High in all\n  0.1, 0.1    # Cluster 5: Low in all\n), ncol = 2, byrow = TRUE)\n\n# Simulate latent sources\nlatent_sources <- NULL\ncluster_labels <- NULL\nfor (i in 1:n_clusters) {\n  immune <- rexp(cells_per_cluster, rate = 1) + cluster_means[i, 1]\n  metabolism <- rnorm(cells_per_cluster, mean = cluster_means[i, 2], sd = 0.5)\n  cell_cycle <- (rbinom(cells_per_cluster, 1, 0.5) * 2 - 1)\n  sources <- cbind(immune, metabolism, cell_cycle)\n  latent_sources <- rbind(latent_sources, sources)\n  cluster_labels <- c(cluster_labels, rep(paste0(\"Cluster_\", i), cells_per_cluster))\n}\n\n# Create gene loadings matrix\ngene_loadings <- matrix(0, nrow = n_genes, ncol = n_sources)\nrownames(gene_loadings) <- gene_names\n\n# Assign high loadings for known gene sets\ngene_loadings[immune_genes, 1] <- abs(rnorm(length(immune_genes), mean = 2))\ngene_loadings[metabolism_genes, 2] <- abs(rnorm(length(metabolism_genes), mean = 2))\ngene_loadings[cell_cycle_genes, 3] <- abs(rnorm(length(cell_cycle_genes), mean = 2))\n\n# Background genes with small random loadings\nremaining <- setdiff(gene_names, c(immune_genes, metabolism_genes, cell_cycle_genes))\ngene_loadings[remaining, ] <- abs(matrix(rnorm(length(remaining) * n_sources, mean = 0.3, sd = 0.2),\n                                         nrow = length(remaining), ncol = n_sources))\n\n# Generate expression matrix\nexpression_matrix <- latent_sources %*% t(gene_loadings)\nexpression_matrix <- expression_matrix + matrix(rnorm(n_cells * n_genes, sd = 1), nrow = n_cells)\n\n# Assign row/column names\nrownames(expression_matrix) <- paste0(\"Cell\", 1:n_cells)\ncolnames(expression_matrix) <- gene_names\n\nx <- expression_matrix\n\n```\n:::\n\n\n\n\n## Preview data\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# check data dimension\nx <- expression_matrix\nx |> dim() |> print() # 2000 cells, 1000 genes (features)\n## [1] 2000 1000\ncluster_labels |> as.factor() |> summary() |> print()\n## Cluster_1 Cluster_2 Cluster_3 Cluster_4 Cluster_5 \n##       400       400       400       400       400\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# perform PCA\nx_scaled <- scale(x)\npca <- prcomp(x, center=TRUE, scale.=FALSE)\neigs <- pca$sdev^2\nvar_exp <- eigs / sum(eigs)\n\nres_pca <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], PC3=pca$x[,3], PC4=pca$x[,4], PC5=pca$x[,5]) |>\n    rownames_to_column(\"sample\") |> \n    as_tibble() \n\nres_pca_loadings <- pca$rotation\n\n# show PCA scores plot\nres_pca |>\n    ggplot(aes(x=PC1, y=PC2, color=cluster_labels)) +\n    geom_point() +\n    labs(title=\"PCA scores plot\", x=\"PC1\", y=\"PC2\") +\n    xlab(paste(\"PC1 (Var: \", round(var_exp[1] * 100, 2), \"%)\")) +\n    ylab(paste(\"PC2 (Var: \", round(var_exp[2] * 100, 2), \"%)\")) +\n    theme_minimal() +\n    theme(legend.title=element_blank())\n\n# show top 10 loadings along PC1\nres_pca_loadings |> \n    as.data.frame() |> \n    rownames_to_column(\"gene\") |> \n    arrange(desc(abs(PC1))) |> \n    head(10) |> \n    ggplot(aes(x=reorder(gene, PC1), y=PC1)) +\n    geom_bar(stat=\"identity\", fill=\"steelblue\") +\n    coord_flip() +\n    labs(title=\"Top genes contributing to PC1\", x=\"gene\", y=\"Loading\") +\n    theme_minimal()\n\n# PCA has actually done quite a good job finding our clusters. The first few principal components clearly separate the major groups, showing that PCA is able to capture dominant sources of variation in the data. \n\n# However, this does not necessarily mean that PCA has recovered the original biological signals (such as immune activity, metabolism, or cell cycle) as separate components. Let’s have a look at the distribution of scores in each components\n\n# Plot densities of the first 3 PCA components\npca_scores <- as.data.frame(pca$x[, 1:3])\npca_scores$Cluster <- cluster_labels\n\npar(mfrow = c(1, 3), mar = c(4, 4, 2, 1))\nplot(density(pca_scores$PC1), main = \"PCA Component 1\", xlab = \"PC1\", col = \"darkred\", lwd = 2)\nplot(density(pca_scores$PC2), main = \"PCA Component 2\", xlab = \"PC2\", col = \"darkblue\", lwd = 2)\nplot(density(pca_scores$PC3), main = \"PCA Component 3\", xlab = \"PC3\", col = \"darkgreen\", lwd = 2)\n\n# The components of the PCA more or less look normal and do not really reflect the true latent factors we simulated [see chapter for details]. \n\n# We can also plot the relationship between the PCA components with all of our true latent factors:\n# Set up 3x3 plotting area: PC1–3 vs latent sources\npar(mfrow = c(3, 3), mar = c(4, 4, 2, 1))\n\nfor (pc_idx in 1:3) {\n  for (latent_idx in 1:3) {\n    plot(pca_scores[[pc_idx]], latent_sources[, latent_idx],\n         xlab = paste0(\"PC\", pc_idx),\n         ylab = c(\"Immune\", \"Metabolism\", \"Cell Cycle\")[latent_idx],\n         main = paste(\"PC\", pc_idx, \"vs\", c(\"Immune\", \"Metabolism\", \"Cell Cycle\")[latent_idx]),\n         #col = as.numeric(cluster_labels),\n         pch = 16)\n  }\n}\n\n# We see that there is some relationship between the PCA components and our latent factors but but PCs are still blended combinations of multiple underlying factors. This means that while PCA helps reveal structure, it may mix together distinct biological processes if those processes happen to contribute variance in similar directions.\n\n```\n\n::: {.cell-output-display}\n![](ICA_files/figure-html/pca-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](ICA_files/figure-html/pca-2.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](ICA_files/figure-html/pca-3.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](ICA_files/figure-html/pca-4.png){width=672}\n:::\n:::\n\n\n\n\n## run ICA\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Run Independent Component Analysis (ICA) on scaled data with 3 components\nica_result <- fastICA(x_scaled, n.comp = 3)\n\n# fastICA: Performs Independent Component Analysis on multivariate data\n\n# Key input parameters:\n# - X: a numeric matrix or data frame with continuous values (e.g., scaled gene expression)\n# - n.comp: number of independent components to extract (must be ≤ number of variables)\n# - alg.typ: algorithm type; \"parallel\" (default, fast) or \"deflation\" (one component at a time)\n# - fun: the nonlinearity function; common choices include \"logcosh\", \"exp\", or \"cube\"\n# - alpha: only used with \"logcosh\", controls the shape of the contrast function\n# - maxit: maximum number of iterations (default: 200)\n# - tol: convergence tolerance (default: 1e-04)\n\nprint(names(ica_result))\n## [1] \"X\" \"K\" \"W\" \"A\" \"S\"\n\n# Output:\n# $S — Estimated independent components (samples × components), main output for analysis.\n# $A — Mixing matrix showing how components combine to form original data.\n# $K — Whitening matrix used to decorrelate input data before ICA.\n# $W — Unmixing matrix that transforms whitened data into independent components.\n# $X — Centered version of the original input data used in the analysis.\n\n# Extract the independent component scores (latent signals)\nica_scores <- as.data.frame(ica_result$S)\n\n# Rename the columns for clarity\ncolnames(ica_scores) <- c(\"ICA 1\", \"ICA 2\", \"ICA 3\")\n\n# Add cluster labels (assumed from previous clustering) for coloring the plot\nica_scores$Cluster <- cluster_labels\n\n# Plot the first two ICA components, colored by cluster\nplot(ica_scores[,c(1,2)],\n     col = as.factor(pca_scores$Cluster),  # coloring by cluster (note: should likely be ica_scores$Cluster)\n     pch = 16, cex = 0.6,\n     main = \"ICA Score Plot\")\n\n# Add legend with cluster labels\nlegend(\"topleft\", legend = unique(pca_scores$Cluster),\n       col = 1:5, pch = 16, title = \"Cluster\")\n\n# The ICA scores plot shows samples colored by true clusters based on simulated biology (immune, metabolism, cell cycle).\n# ICA separates clusters more distinctly than PCA by recovering statistically independent signals.\n# ICA Component 1 appears to reflect immune activity (high in Clusters 1 & 4, low in 2 & 5).\n# ICA Component 2 likely captures metabolism (low in Clusters 1 & 5, high in 2 & 4).\n# The components show meaningful biological gradients across the samples.\n\n# Let's see if ICA could recover our original latent signals\n# Plot densities of the first 3 PCA components\npar(mfrow = c(1, 3), mar = c(4, 4, 2, 1))\nplot(density(ica_scores[,1]), main = \"ICA Component 1\", xlab = \"PC1\", col = \"darkred\", lwd = 2)\nplot(density(ica_scores[,2]), main = \"ICA Component 2\", xlab = \"PC2\", col = \"darkblue\", lwd = 2)\nplot(density(ica_scores[,3]), main = \"ICA Component 3\", xlab = \"PC3\", col = \"darkgreen\", lwd = 2)\n\n# This looks very similar to our true signal the first component is immune, the second is metabolism and the third captured cell cycle (see chapter). This is exactly what ICA is good at: recovering independent sources that were mixed across thousands of genes. It allows us to reduce the data to a few components that may correspond directly to real biological processes. This is something that PCA often fails to do when the sources overlap or have similar variance\n```\n\n::: {.cell-output-display}\n![](ICA_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](ICA_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\n\n\n## Exercise: interpret ICA\n\n*identifying genes driving ICA components*\n\nExplore the ICA mixing matrix (`A`) to determine which genes contribute most to each independent component. Your goal is to extract the top-weighted genes for each component, interpret their biological relevance using the provided `db_genes` annotation table, and suggest what underlying signal each component may represent (e.g., immune activity, metabolism, or cell cycle).\n\n**Hints**\n\n- Use `ica_result$A` to access the mixing matrix.\n- Take the absolute value of loadings to identify the strongest contributors (positive or negative).\n- Use `order()` or `sort()` to rank genes by their contribution to each component.\n- Match the top gene names to `db_genes` to find their annotated biological function.\n- Focus on patterns: do multiple top genes belong to the same functional group?\n- Compare your findings to the ICA score plots — do the gene signatures align with sample-level structure?\n\n**Example answer**\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Extract the mixing matrix\nA <- ica_result$A  # rows = components, columns = genes\ncolnames(A) <- colnames(x)  # assign gene names to columns if not already\n\n# Loop over all components\ntop_genes_all <- list()\n\nfor (i in 1:nrow(A)) {\n  o <- order(abs(A[i, ]), decreasing = TRUE)[1:20]\n  top_genes <- colnames(A)[o]\n  \n  annotated <- db_genes |> \n    filter(gene %in% top_genes) |> \n    mutate(Component = paste0(\"ICA_\", i))\n  \n  top_genes_all[[i]] <- annotated\n}\n\n# Combine all results into a single data frame\ntop_genes_df <- bind_rows(top_genes_all)\n\n# View the annotated top genes by component\nprint(top_genes_df)\n##       gene   category Component\n## 1     CD3D     Immune     ICA_1\n## 2      CD4     Immune     ICA_1\n## 3     CD8A     Immune     ICA_1\n## 4     IFNG     Immune     ICA_1\n## 5      IL2     Immune     ICA_1\n## 6    PTPRC     Immune     ICA_1\n## 7     GZMB     Immune     ICA_1\n## 8      LCK     Immune     ICA_1\n## 9     CCR7     Immune     ICA_1\n## 10 HLA-DRA     Immune     ICA_1\n## 11     HK2 Metabolism     ICA_2\n## 12    LDHA Metabolism     ICA_2\n## 13     PKM Metabolism     ICA_2\n## 14    G6PD Metabolism     ICA_2\n## 15    ACLY Metabolism     ICA_2\n## 16    PGK1 Metabolism     ICA_2\n## 17   CPT1A Metabolism     ICA_2\n## 18    FASN Metabolism     ICA_2\n## 19   ACACA Metabolism     ICA_2\n## 20    CDK1 Cell Cycle     ICA_3\n## 21   CCNB1 Cell Cycle     ICA_3\n## 22   MKI67 Cell Cycle     ICA_3\n## 23    PCNA Cell Cycle     ICA_3\n## 24   TOP2A Cell Cycle     ICA_3\n## 25    BUB1 Cell Cycle     ICA_3\n## 26   CDC20 Cell Cycle     ICA_3\n## 27    PLK1 Cell Cycle     ICA_3\n## 28   AURKB Cell Cycle     ICA_3\n## 29   CENPA Cell Cycle     ICA_3\n```\n:::\n\n\n\n\nIn our simulated data it is very easy to see which component corresponds to which biological signal. In real data, however, it is often not so straightforward. You may need to look at the top genes and their annotations to see if they make sense in the context of your biological question.\n\nAlso note, that unlike PCA, which orders components by variance explained, ICA components are unordered. The algorithm does not rank them by “importance.” This means:\n\n- You may want to sort or label components manually based on interpretation.\n- You can match ICA components to known sources (e.g. simulated immune or metabolism signals) using correlation or cluster separation.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Correlation with true sources\ncor(ica_result$S, latent_sources)\n##           immune  metabolism   cell_cycle\n## [1,]  0.99565648  0.20075925  0.001202599\n## [2,]  0.03306877 -0.97261234 -0.003206194\n## [3,] -0.03741380  0.00472256 -0.992583786\n```\n:::\n",
    "supporting": [
      "ICA_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}