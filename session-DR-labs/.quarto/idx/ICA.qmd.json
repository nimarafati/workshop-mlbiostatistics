{"title":"ICA","markdown":{"yaml":{"title":"ICA","format":{"html":{"toc":true,"toc-location":"right","number-sections":true,"code-fold":false,"sidebar":true}},"editor":"visual","editor_options":{"chunk_output_type":"console"},"knitr":{"opts_chunk":{"message":false,"warning":false,"code-fold":false,"include":true,"collapse":true,"eval":true,"fig.show":"hold"}}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\nIndependent Component Analysis (ICA) is an unsupervised method that separates multivariate data into statistically independent signals, often used to uncover hidden biological processes. In this tutorial, you'll learn how to apply ICA to gene expression data and interpret both sample structure and gene-level drivers.\n\nTutorial is based on [https://payamemami.com/ica_basics/](https://payamemami.com/ica_basics/), a document with more detailed introduction to the methods, including its mathematical foundations.\n\n## Data\n\n```{r}\n#| include: false\n#| eval: false\n\n# Payam's original data simulation code\n\n# Load libraries\nlibrary(tidyverse)\nlibrary(fastICA)\nlibrary(ggplot2)\n\n# Simulate data\n\n# Set parameters\nset.seed(123)\nn_genes <- 1000\nn_cells <- 2000\nn_sources <- 3\nn_clusters <- 5\ncells_per_cluster <- n_cells / n_clusters\n\n# Define cluster-specific means for latent sources\ncluster_means <- matrix(c(\n  3.0, 0.5,   # Cluster 1: High immune, low metabolism\n  0.1, 2.0,    # Cluster 2: Low immune, high metabolism\n  1.5, 1.5,   # Cluster 3: Moderate all\n  3.0, 2.5,  # Cluster 4: High in all\n  0.1, 0.1  # Cluster 5: Low in all\n), ncol = 2, byrow = TRUE)\n\n# Simulate latent sources for each cluster\nlatent_sources <- NULL\ncluster_labels <- NULL\nfor (i in 1:n_clusters) {\n  \n  immune <- rexp(cells_per_cluster, rate = 1) + cluster_means[i, 1]\n  metabolism <- rnorm(cells_per_cluster, mean = cluster_means[i, 2], sd = 0.5)\n  cell_cycle <-( (rbinom(cells_per_cluster, 1, 0.5) * 2 - 1))\n  sources <- cbind(immune, metabolism, cell_cycle)\n  latent_sources <- rbind(latent_sources, sources)\n  cluster_labels <- c(cluster_labels, rep(paste0(\"Cluster \", i), cells_per_cluster))\n  \n}\n\n# Simulate gene loadings (dense, positive)\ngene_loadings <- abs(matrix(rnorm(n_genes * n_sources), nrow = n_genes, ncol = n_sources))\n\n# Generate expression matrix with noise\nexpression_matrix <- latent_sources %*% t(gene_loadings)\nexpression_matrix <- expression_matrix + matrix(rnorm(n_cells * n_genes, sd = 1), nrow = n_cells)\n\n```\n\n```{r}\n# adjust data simulation code to include some gene names for the main categories\n\n# Load necessary library\nlibrary(tidyverse)\nlibrary(fastICA)\n\n# Set parameters\nset.seed(123)\nn_cells <- 2000\nn_sources <- 3\nn_clusters <- 5\ncells_per_cluster <- n_cells / n_clusters\n\n# Define gene sets\nimmune_genes <- c(\"CD3D\", \"CD4\", \"CD8A\", \"IFNG\", \"IL2\", \"PTPRC\", \"GZMB\", \"LCK\", \"CCR7\", \"HLA-DRA\")\nmetabolism_genes <- c(\"HK2\", \"LDHA\", \"PKM\", \"G6PD\", \"ACLY\", \"IDH1\", \"PGK1\", \"CPT1A\", \"FASN\", \"ACACA\")\ncell_cycle_genes <- c(\"CDK1\", \"CCNB1\", \"MKI67\", \"PCNA\", \"TOP2A\", \"BUB1\", \"CDC20\", \"PLK1\", \"AURKB\", \"CENPA\")\n\ndb_genes <- data.frame(\n  gene = c(immune_genes, metabolism_genes, cell_cycle_genes),\n  category = c(rep(\"Immune\", length(immune_genes)),\n               rep(\"Metabolism\", length(metabolism_genes)),\n               rep(\"Cell Cycle\", length(cell_cycle_genes)))\n)\n\n# Fill up to 1000 genes with generic names\nother_genes <- paste0(\"GENE\", 1:(1000 - length(immune_genes) - length(metabolism_genes) - length(cell_cycle_genes)))\ngene_names <- c(immune_genes, metabolism_genes, cell_cycle_genes, other_genes)\nn_genes <- length(gene_names)\n\n# Define cluster-specific means for latent sources (immune, metabolism)\ncluster_means <- matrix(c(\n  3.0, 0.5,   # Cluster 1: High immune, low metabolism\n  0.1, 2.0,   # Cluster 2: Low immune, high metabolism\n  1.5, 1.5,   # Cluster 3: Moderate all\n  3.0, 2.5,   # Cluster 4: High in all\n  0.1, 0.1    # Cluster 5: Low in all\n), ncol = 2, byrow = TRUE)\n\n# Simulate latent sources\nlatent_sources <- NULL\ncluster_labels <- NULL\nfor (i in 1:n_clusters) {\n  immune <- rexp(cells_per_cluster, rate = 1) + cluster_means[i, 1]\n  metabolism <- rnorm(cells_per_cluster, mean = cluster_means[i, 2], sd = 0.5)\n  cell_cycle <- (rbinom(cells_per_cluster, 1, 0.5) * 2 - 1)\n  sources <- cbind(immune, metabolism, cell_cycle)\n  latent_sources <- rbind(latent_sources, sources)\n  cluster_labels <- c(cluster_labels, rep(paste0(\"Cluster_\", i), cells_per_cluster))\n}\n\n# Create gene loadings matrix\ngene_loadings <- matrix(0, nrow = n_genes, ncol = n_sources)\nrownames(gene_loadings) <- gene_names\n\n# Assign high loadings for known gene sets\ngene_loadings[immune_genes, 1] <- abs(rnorm(length(immune_genes), mean = 2))\ngene_loadings[metabolism_genes, 2] <- abs(rnorm(length(metabolism_genes), mean = 2))\ngene_loadings[cell_cycle_genes, 3] <- abs(rnorm(length(cell_cycle_genes), mean = 2))\n\n# Background genes with small random loadings\nremaining <- setdiff(gene_names, c(immune_genes, metabolism_genes, cell_cycle_genes))\ngene_loadings[remaining, ] <- abs(matrix(rnorm(length(remaining) * n_sources, mean = 0.3, sd = 0.2),\n                                         nrow = length(remaining), ncol = n_sources))\n\n# Generate expression matrix\nexpression_matrix <- latent_sources %*% t(gene_loadings)\nexpression_matrix <- expression_matrix + matrix(rnorm(n_cells * n_genes, sd = 1), nrow = n_cells)\n\n# Assign row/column names\nrownames(expression_matrix) <- paste0(\"Cell\", 1:n_cells)\ncolnames(expression_matrix) <- gene_names\n\nx <- expression_matrix\n\n```\n\n## Preview data\n\n```{r}\n# check data dimension\nx <- expression_matrix\nx |> dim() |> print() # 2000 cells, 1000 genes (features)\ncluster_labels |> as.factor() |> summary() |> print()\n\n```\n\n```{r}\n#| label: pca\n#| fig.keep: all\n\n# perform PCA\nx_scaled <- scale(x)\npca <- prcomp(x, center=TRUE, scale.=FALSE)\neigs <- pca$sdev^2\nvar_exp <- eigs / sum(eigs)\n\nres_pca <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], PC3=pca$x[,3], PC4=pca$x[,4], PC5=pca$x[,5]) |>\n    rownames_to_column(\"sample\") |> \n    as_tibble() \n\nres_pca_loadings <- pca$rotation\n\n# show PCA scores plot\nres_pca |>\n    ggplot(aes(x=PC1, y=PC2, color=cluster_labels)) +\n    geom_point() +\n    labs(title=\"PCA scores plot\", x=\"PC1\", y=\"PC2\") +\n    xlab(paste(\"PC1 (Var: \", round(var_exp[1] * 100, 2), \"%)\")) +\n    ylab(paste(\"PC2 (Var: \", round(var_exp[2] * 100, 2), \"%)\")) +\n    theme_minimal() +\n    theme(legend.title=element_blank())\n\n# show top 10 loadings along PC1\nres_pca_loadings |> \n    as.data.frame() |> \n    rownames_to_column(\"gene\") |> \n    arrange(desc(abs(PC1))) |> \n    head(10) |> \n    ggplot(aes(x=reorder(gene, PC1), y=PC1)) +\n    geom_bar(stat=\"identity\", fill=\"steelblue\") +\n    coord_flip() +\n    labs(title=\"Top genes contributing to PC1\", x=\"gene\", y=\"Loading\") +\n    theme_minimal()\n\n# PCA has actually done quite a good job finding our clusters. The first few principal components clearly separate the major groups, showing that PCA is able to capture dominant sources of variation in the data. \n\n# However, this does not necessarily mean that PCA has recovered the original biological signals (such as immune activity, metabolism, or cell cycle) as separate components. Let’s have a look at the distribution of scores in each components\n\n# Plot densities of the first 3 PCA components\npca_scores <- as.data.frame(pca$x[, 1:3])\npca_scores$Cluster <- cluster_labels\n\npar(mfrow = c(1, 3), mar = c(4, 4, 2, 1))\nplot(density(pca_scores$PC1), main = \"PCA Component 1\", xlab = \"PC1\", col = \"darkred\", lwd = 2)\nplot(density(pca_scores$PC2), main = \"PCA Component 2\", xlab = \"PC2\", col = \"darkblue\", lwd = 2)\nplot(density(pca_scores$PC3), main = \"PCA Component 3\", xlab = \"PC3\", col = \"darkgreen\", lwd = 2)\n\n# The components of the PCA more or less look normal and do not really reflect the true latent factors we simulated [see chapter for details]. \n\n# We can also plot the relationship between the PCA components with all of our true latent factors:\n# Set up 3x3 plotting area: PC1–3 vs latent sources\npar(mfrow = c(3, 3), mar = c(4, 4, 2, 1))\n\nfor (pc_idx in 1:3) {\n  for (latent_idx in 1:3) {\n    plot(pca_scores[[pc_idx]], latent_sources[, latent_idx],\n         xlab = paste0(\"PC\", pc_idx),\n         ylab = c(\"Immune\", \"Metabolism\", \"Cell Cycle\")[latent_idx],\n         main = paste(\"PC\", pc_idx, \"vs\", c(\"Immune\", \"Metabolism\", \"Cell Cycle\")[latent_idx]),\n         #col = as.numeric(cluster_labels),\n         pch = 16)\n  }\n}\n\n# We see that there is some relationship between the PCA components and our latent factors but but PCs are still blended combinations of multiple underlying factors. This means that while PCA helps reveal structure, it may mix together distinct biological processes if those processes happen to contribute variance in similar directions.\n\n```\n\n## run ICA\n```{r}\n# Run Independent Component Analysis (ICA) on scaled data with 3 components\nica_result <- fastICA(x_scaled, n.comp = 3)\n\n# fastICA: Performs Independent Component Analysis on multivariate data\n\n# Key input parameters:\n# - X: a numeric matrix or data frame with continuous values (e.g., scaled gene expression)\n# - n.comp: number of independent components to extract (must be ≤ number of variables)\n# - alg.typ: algorithm type; \"parallel\" (default, fast) or \"deflation\" (one component at a time)\n# - fun: the nonlinearity function; common choices include \"logcosh\", \"exp\", or \"cube\"\n# - alpha: only used with \"logcosh\", controls the shape of the contrast function\n# - maxit: maximum number of iterations (default: 200)\n# - tol: convergence tolerance (default: 1e-04)\n\nprint(names(ica_result))\n\n# Output:\n# $S — Estimated independent components (samples × components), main output for analysis.\n# $A — Mixing matrix showing how components combine to form original data.\n# $K — Whitening matrix used to decorrelate input data before ICA.\n# $W — Unmixing matrix that transforms whitened data into independent components.\n# $X — Centered version of the original input data used in the analysis.\n\n# Extract the independent component scores (latent signals)\nica_scores <- as.data.frame(ica_result$S)\n\n# Rename the columns for clarity\ncolnames(ica_scores) <- c(\"ICA 1\", \"ICA 2\", \"ICA 3\")\n\n# Add cluster labels (assumed from previous clustering) for coloring the plot\nica_scores$Cluster <- cluster_labels\n\n# Plot the first two ICA components, colored by cluster\nplot(ica_scores[,c(1,2)],\n     col = as.factor(pca_scores$Cluster),  # coloring by cluster (note: should likely be ica_scores$Cluster)\n     pch = 16, cex = 0.6,\n     main = \"ICA Score Plot\")\n\n# Add legend with cluster labels\nlegend(\"topleft\", legend = unique(pca_scores$Cluster),\n       col = 1:5, pch = 16, title = \"Cluster\")\n\n# The ICA scores plot shows samples colored by true clusters based on simulated biology (immune, metabolism, cell cycle).\n# ICA separates clusters more distinctly than PCA by recovering statistically independent signals.\n# ICA Component 1 appears to reflect immune activity (high in Clusters 1 & 4, low in 2 & 5).\n# ICA Component 2 likely captures metabolism (low in Clusters 1 & 5, high in 2 & 4).\n# The components show meaningful biological gradients across the samples.\n\n# Let's see if ICA could recover our original latent signals\n# Plot densities of the first 3 PCA components\npar(mfrow = c(1, 3), mar = c(4, 4, 2, 1))\nplot(density(ica_scores[,1]), main = \"ICA Component 1\", xlab = \"PC1\", col = \"darkred\", lwd = 2)\nplot(density(ica_scores[,2]), main = \"ICA Component 2\", xlab = \"PC2\", col = \"darkblue\", lwd = 2)\nplot(density(ica_scores[,3]), main = \"ICA Component 3\", xlab = \"PC3\", col = \"darkgreen\", lwd = 2)\n\n# This looks very similar to our true signal the first component is immune, the second is metabolism and the third captured cell cycle (see chapter). This is exactly what ICA is good at: recovering independent sources that were mixed across thousands of genes. It allows us to reduce the data to a few components that may correspond directly to real biological processes. This is something that PCA often fails to do when the sources overlap or have similar variance\n```\n\n## Exercise: interpret ICA\n\n*identifying genes driving ICA components*\n\nExplore the ICA mixing matrix (`A`) to determine which genes contribute most to each independent component. Your goal is to extract the top-weighted genes for each component, interpret their biological relevance using the provided `db_genes` annotation table, and suggest what underlying signal each component may represent (e.g., immune activity, metabolism, or cell cycle).\n\n**Hints**\n\n- Use `ica_result$A` to access the mixing matrix.\n- Take the absolute value of loadings to identify the strongest contributors (positive or negative).\n- Use `order()` or `sort()` to rank genes by their contribution to each component.\n- Match the top gene names to `db_genes` to find their annotated biological function.\n- Focus on patterns: do multiple top genes belong to the same functional group?\n- Compare your findings to the ICA score plots — do the gene signatures align with sample-level structure?\n\n**Example answer**\n\n```{r}\n# Extract the mixing matrix\nA <- ica_result$A  # rows = components, columns = genes\ncolnames(A) <- colnames(x)  # assign gene names to columns if not already\n\n# Loop over all components\ntop_genes_all <- list()\n\nfor (i in 1:nrow(A)) {\n  o <- order(abs(A[i, ]), decreasing = TRUE)[1:20]\n  top_genes <- colnames(A)[o]\n  \n  annotated <- db_genes |> \n    filter(gene %in% top_genes) |> \n    mutate(Component = paste0(\"ICA_\", i))\n  \n  top_genes_all[[i]] <- annotated\n}\n\n# Combine all results into a single data frame\ntop_genes_df <- bind_rows(top_genes_all)\n\n# View the annotated top genes by component\nprint(top_genes_df)\n\n```\n\nIn our simulated data it is very easy to see which component corresponds to which biological signal. In real data, however, it is often not so straightforward. You may need to look at the top genes and their annotations to see if they make sense in the context of your biological question.\n\nAlso note, that unlike PCA, which orders components by variance explained, ICA components are unordered. The algorithm does not rank them by “importance.” This means:\n\n- You may want to sort or label components manually based on interpretation.\n- You can match ICA components to known sources (e.g. simulated immune or metabolism signals) using correlation or cluster separation.\n\n```{r}\n# Correlation with true sources\ncor(ica_result$S, latent_sources)\n```\n\n\n","srcMarkdownNoYaml":"\n\n## Introduction\n\nIndependent Component Analysis (ICA) is an unsupervised method that separates multivariate data into statistically independent signals, often used to uncover hidden biological processes. In this tutorial, you'll learn how to apply ICA to gene expression data and interpret both sample structure and gene-level drivers.\n\nTutorial is based on [https://payamemami.com/ica_basics/](https://payamemami.com/ica_basics/), a document with more detailed introduction to the methods, including its mathematical foundations.\n\n## Data\n\n```{r}\n#| include: false\n#| eval: false\n\n# Payam's original data simulation code\n\n# Load libraries\nlibrary(tidyverse)\nlibrary(fastICA)\nlibrary(ggplot2)\n\n# Simulate data\n\n# Set parameters\nset.seed(123)\nn_genes <- 1000\nn_cells <- 2000\nn_sources <- 3\nn_clusters <- 5\ncells_per_cluster <- n_cells / n_clusters\n\n# Define cluster-specific means for latent sources\ncluster_means <- matrix(c(\n  3.0, 0.5,   # Cluster 1: High immune, low metabolism\n  0.1, 2.0,    # Cluster 2: Low immune, high metabolism\n  1.5, 1.5,   # Cluster 3: Moderate all\n  3.0, 2.5,  # Cluster 4: High in all\n  0.1, 0.1  # Cluster 5: Low in all\n), ncol = 2, byrow = TRUE)\n\n# Simulate latent sources for each cluster\nlatent_sources <- NULL\ncluster_labels <- NULL\nfor (i in 1:n_clusters) {\n  \n  immune <- rexp(cells_per_cluster, rate = 1) + cluster_means[i, 1]\n  metabolism <- rnorm(cells_per_cluster, mean = cluster_means[i, 2], sd = 0.5)\n  cell_cycle <-( (rbinom(cells_per_cluster, 1, 0.5) * 2 - 1))\n  sources <- cbind(immune, metabolism, cell_cycle)\n  latent_sources <- rbind(latent_sources, sources)\n  cluster_labels <- c(cluster_labels, rep(paste0(\"Cluster \", i), cells_per_cluster))\n  \n}\n\n# Simulate gene loadings (dense, positive)\ngene_loadings <- abs(matrix(rnorm(n_genes * n_sources), nrow = n_genes, ncol = n_sources))\n\n# Generate expression matrix with noise\nexpression_matrix <- latent_sources %*% t(gene_loadings)\nexpression_matrix <- expression_matrix + matrix(rnorm(n_cells * n_genes, sd = 1), nrow = n_cells)\n\n```\n\n```{r}\n# adjust data simulation code to include some gene names for the main categories\n\n# Load necessary library\nlibrary(tidyverse)\nlibrary(fastICA)\n\n# Set parameters\nset.seed(123)\nn_cells <- 2000\nn_sources <- 3\nn_clusters <- 5\ncells_per_cluster <- n_cells / n_clusters\n\n# Define gene sets\nimmune_genes <- c(\"CD3D\", \"CD4\", \"CD8A\", \"IFNG\", \"IL2\", \"PTPRC\", \"GZMB\", \"LCK\", \"CCR7\", \"HLA-DRA\")\nmetabolism_genes <- c(\"HK2\", \"LDHA\", \"PKM\", \"G6PD\", \"ACLY\", \"IDH1\", \"PGK1\", \"CPT1A\", \"FASN\", \"ACACA\")\ncell_cycle_genes <- c(\"CDK1\", \"CCNB1\", \"MKI67\", \"PCNA\", \"TOP2A\", \"BUB1\", \"CDC20\", \"PLK1\", \"AURKB\", \"CENPA\")\n\ndb_genes <- data.frame(\n  gene = c(immune_genes, metabolism_genes, cell_cycle_genes),\n  category = c(rep(\"Immune\", length(immune_genes)),\n               rep(\"Metabolism\", length(metabolism_genes)),\n               rep(\"Cell Cycle\", length(cell_cycle_genes)))\n)\n\n# Fill up to 1000 genes with generic names\nother_genes <- paste0(\"GENE\", 1:(1000 - length(immune_genes) - length(metabolism_genes) - length(cell_cycle_genes)))\ngene_names <- c(immune_genes, metabolism_genes, cell_cycle_genes, other_genes)\nn_genes <- length(gene_names)\n\n# Define cluster-specific means for latent sources (immune, metabolism)\ncluster_means <- matrix(c(\n  3.0, 0.5,   # Cluster 1: High immune, low metabolism\n  0.1, 2.0,   # Cluster 2: Low immune, high metabolism\n  1.5, 1.5,   # Cluster 3: Moderate all\n  3.0, 2.5,   # Cluster 4: High in all\n  0.1, 0.1    # Cluster 5: Low in all\n), ncol = 2, byrow = TRUE)\n\n# Simulate latent sources\nlatent_sources <- NULL\ncluster_labels <- NULL\nfor (i in 1:n_clusters) {\n  immune <- rexp(cells_per_cluster, rate = 1) + cluster_means[i, 1]\n  metabolism <- rnorm(cells_per_cluster, mean = cluster_means[i, 2], sd = 0.5)\n  cell_cycle <- (rbinom(cells_per_cluster, 1, 0.5) * 2 - 1)\n  sources <- cbind(immune, metabolism, cell_cycle)\n  latent_sources <- rbind(latent_sources, sources)\n  cluster_labels <- c(cluster_labels, rep(paste0(\"Cluster_\", i), cells_per_cluster))\n}\n\n# Create gene loadings matrix\ngene_loadings <- matrix(0, nrow = n_genes, ncol = n_sources)\nrownames(gene_loadings) <- gene_names\n\n# Assign high loadings for known gene sets\ngene_loadings[immune_genes, 1] <- abs(rnorm(length(immune_genes), mean = 2))\ngene_loadings[metabolism_genes, 2] <- abs(rnorm(length(metabolism_genes), mean = 2))\ngene_loadings[cell_cycle_genes, 3] <- abs(rnorm(length(cell_cycle_genes), mean = 2))\n\n# Background genes with small random loadings\nremaining <- setdiff(gene_names, c(immune_genes, metabolism_genes, cell_cycle_genes))\ngene_loadings[remaining, ] <- abs(matrix(rnorm(length(remaining) * n_sources, mean = 0.3, sd = 0.2),\n                                         nrow = length(remaining), ncol = n_sources))\n\n# Generate expression matrix\nexpression_matrix <- latent_sources %*% t(gene_loadings)\nexpression_matrix <- expression_matrix + matrix(rnorm(n_cells * n_genes, sd = 1), nrow = n_cells)\n\n# Assign row/column names\nrownames(expression_matrix) <- paste0(\"Cell\", 1:n_cells)\ncolnames(expression_matrix) <- gene_names\n\nx <- expression_matrix\n\n```\n\n## Preview data\n\n```{r}\n# check data dimension\nx <- expression_matrix\nx |> dim() |> print() # 2000 cells, 1000 genes (features)\ncluster_labels |> as.factor() |> summary() |> print()\n\n```\n\n```{r}\n#| label: pca\n#| fig.keep: all\n\n# perform PCA\nx_scaled <- scale(x)\npca <- prcomp(x, center=TRUE, scale.=FALSE)\neigs <- pca$sdev^2\nvar_exp <- eigs / sum(eigs)\n\nres_pca <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], PC3=pca$x[,3], PC4=pca$x[,4], PC5=pca$x[,5]) |>\n    rownames_to_column(\"sample\") |> \n    as_tibble() \n\nres_pca_loadings <- pca$rotation\n\n# show PCA scores plot\nres_pca |>\n    ggplot(aes(x=PC1, y=PC2, color=cluster_labels)) +\n    geom_point() +\n    labs(title=\"PCA scores plot\", x=\"PC1\", y=\"PC2\") +\n    xlab(paste(\"PC1 (Var: \", round(var_exp[1] * 100, 2), \"%)\")) +\n    ylab(paste(\"PC2 (Var: \", round(var_exp[2] * 100, 2), \"%)\")) +\n    theme_minimal() +\n    theme(legend.title=element_blank())\n\n# show top 10 loadings along PC1\nres_pca_loadings |> \n    as.data.frame() |> \n    rownames_to_column(\"gene\") |> \n    arrange(desc(abs(PC1))) |> \n    head(10) |> \n    ggplot(aes(x=reorder(gene, PC1), y=PC1)) +\n    geom_bar(stat=\"identity\", fill=\"steelblue\") +\n    coord_flip() +\n    labs(title=\"Top genes contributing to PC1\", x=\"gene\", y=\"Loading\") +\n    theme_minimal()\n\n# PCA has actually done quite a good job finding our clusters. The first few principal components clearly separate the major groups, showing that PCA is able to capture dominant sources of variation in the data. \n\n# However, this does not necessarily mean that PCA has recovered the original biological signals (such as immune activity, metabolism, or cell cycle) as separate components. Let’s have a look at the distribution of scores in each components\n\n# Plot densities of the first 3 PCA components\npca_scores <- as.data.frame(pca$x[, 1:3])\npca_scores$Cluster <- cluster_labels\n\npar(mfrow = c(1, 3), mar = c(4, 4, 2, 1))\nplot(density(pca_scores$PC1), main = \"PCA Component 1\", xlab = \"PC1\", col = \"darkred\", lwd = 2)\nplot(density(pca_scores$PC2), main = \"PCA Component 2\", xlab = \"PC2\", col = \"darkblue\", lwd = 2)\nplot(density(pca_scores$PC3), main = \"PCA Component 3\", xlab = \"PC3\", col = \"darkgreen\", lwd = 2)\n\n# The components of the PCA more or less look normal and do not really reflect the true latent factors we simulated [see chapter for details]. \n\n# We can also plot the relationship between the PCA components with all of our true latent factors:\n# Set up 3x3 plotting area: PC1–3 vs latent sources\npar(mfrow = c(3, 3), mar = c(4, 4, 2, 1))\n\nfor (pc_idx in 1:3) {\n  for (latent_idx in 1:3) {\n    plot(pca_scores[[pc_idx]], latent_sources[, latent_idx],\n         xlab = paste0(\"PC\", pc_idx),\n         ylab = c(\"Immune\", \"Metabolism\", \"Cell Cycle\")[latent_idx],\n         main = paste(\"PC\", pc_idx, \"vs\", c(\"Immune\", \"Metabolism\", \"Cell Cycle\")[latent_idx]),\n         #col = as.numeric(cluster_labels),\n         pch = 16)\n  }\n}\n\n# We see that there is some relationship between the PCA components and our latent factors but but PCs are still blended combinations of multiple underlying factors. This means that while PCA helps reveal structure, it may mix together distinct biological processes if those processes happen to contribute variance in similar directions.\n\n```\n\n## run ICA\n```{r}\n# Run Independent Component Analysis (ICA) on scaled data with 3 components\nica_result <- fastICA(x_scaled, n.comp = 3)\n\n# fastICA: Performs Independent Component Analysis on multivariate data\n\n# Key input parameters:\n# - X: a numeric matrix or data frame with continuous values (e.g., scaled gene expression)\n# - n.comp: number of independent components to extract (must be ≤ number of variables)\n# - alg.typ: algorithm type; \"parallel\" (default, fast) or \"deflation\" (one component at a time)\n# - fun: the nonlinearity function; common choices include \"logcosh\", \"exp\", or \"cube\"\n# - alpha: only used with \"logcosh\", controls the shape of the contrast function\n# - maxit: maximum number of iterations (default: 200)\n# - tol: convergence tolerance (default: 1e-04)\n\nprint(names(ica_result))\n\n# Output:\n# $S — Estimated independent components (samples × components), main output for analysis.\n# $A — Mixing matrix showing how components combine to form original data.\n# $K — Whitening matrix used to decorrelate input data before ICA.\n# $W — Unmixing matrix that transforms whitened data into independent components.\n# $X — Centered version of the original input data used in the analysis.\n\n# Extract the independent component scores (latent signals)\nica_scores <- as.data.frame(ica_result$S)\n\n# Rename the columns for clarity\ncolnames(ica_scores) <- c(\"ICA 1\", \"ICA 2\", \"ICA 3\")\n\n# Add cluster labels (assumed from previous clustering) for coloring the plot\nica_scores$Cluster <- cluster_labels\n\n# Plot the first two ICA components, colored by cluster\nplot(ica_scores[,c(1,2)],\n     col = as.factor(pca_scores$Cluster),  # coloring by cluster (note: should likely be ica_scores$Cluster)\n     pch = 16, cex = 0.6,\n     main = \"ICA Score Plot\")\n\n# Add legend with cluster labels\nlegend(\"topleft\", legend = unique(pca_scores$Cluster),\n       col = 1:5, pch = 16, title = \"Cluster\")\n\n# The ICA scores plot shows samples colored by true clusters based on simulated biology (immune, metabolism, cell cycle).\n# ICA separates clusters more distinctly than PCA by recovering statistically independent signals.\n# ICA Component 1 appears to reflect immune activity (high in Clusters 1 & 4, low in 2 & 5).\n# ICA Component 2 likely captures metabolism (low in Clusters 1 & 5, high in 2 & 4).\n# The components show meaningful biological gradients across the samples.\n\n# Let's see if ICA could recover our original latent signals\n# Plot densities of the first 3 PCA components\npar(mfrow = c(1, 3), mar = c(4, 4, 2, 1))\nplot(density(ica_scores[,1]), main = \"ICA Component 1\", xlab = \"PC1\", col = \"darkred\", lwd = 2)\nplot(density(ica_scores[,2]), main = \"ICA Component 2\", xlab = \"PC2\", col = \"darkblue\", lwd = 2)\nplot(density(ica_scores[,3]), main = \"ICA Component 3\", xlab = \"PC3\", col = \"darkgreen\", lwd = 2)\n\n# This looks very similar to our true signal the first component is immune, the second is metabolism and the third captured cell cycle (see chapter). This is exactly what ICA is good at: recovering independent sources that were mixed across thousands of genes. It allows us to reduce the data to a few components that may correspond directly to real biological processes. This is something that PCA often fails to do when the sources overlap or have similar variance\n```\n\n## Exercise: interpret ICA\n\n*identifying genes driving ICA components*\n\nExplore the ICA mixing matrix (`A`) to determine which genes contribute most to each independent component. Your goal is to extract the top-weighted genes for each component, interpret their biological relevance using the provided `db_genes` annotation table, and suggest what underlying signal each component may represent (e.g., immune activity, metabolism, or cell cycle).\n\n**Hints**\n\n- Use `ica_result$A` to access the mixing matrix.\n- Take the absolute value of loadings to identify the strongest contributors (positive or negative).\n- Use `order()` or `sort()` to rank genes by their contribution to each component.\n- Match the top gene names to `db_genes` to find their annotated biological function.\n- Focus on patterns: do multiple top genes belong to the same functional group?\n- Compare your findings to the ICA score plots — do the gene signatures align with sample-level structure?\n\n**Example answer**\n\n```{r}\n# Extract the mixing matrix\nA <- ica_result$A  # rows = components, columns = genes\ncolnames(A) <- colnames(x)  # assign gene names to columns if not already\n\n# Loop over all components\ntop_genes_all <- list()\n\nfor (i in 1:nrow(A)) {\n  o <- order(abs(A[i, ]), decreasing = TRUE)[1:20]\n  top_genes <- colnames(A)[o]\n  \n  annotated <- db_genes |> \n    filter(gene %in% top_genes) |> \n    mutate(Component = paste0(\"ICA_\", i))\n  \n  top_genes_all[[i]] <- annotated\n}\n\n# Combine all results into a single data frame\ntop_genes_df <- bind_rows(top_genes_all)\n\n# View the annotated top genes by component\nprint(top_genes_df)\n\n```\n\nIn our simulated data it is very easy to see which component corresponds to which biological signal. In real data, however, it is often not so straightforward. You may need to look at the top genes and their annotations to see if they make sense in the context of your biological question.\n\nAlso note, that unlike PCA, which orders components by variance explained, ICA components are unordered. The algorithm does not rank them by “importance.” This means:\n\n- You may want to sort or label components manually based on interpretation.\n- You can match ICA components to known sources (e.g. simulated immune or metabolism signals) using correlation or cluster separation.\n\n```{r}\n# Correlation with true sources\ncor(ica_result$S, latent_sources)\n```\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":true,"output-file":"ICA.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.36","bibliography":["references.bib"],"theme":"spacebar","mermaid":{"theme":"forest"},"title":"ICA","editor":"visual","editor_options":{"chunk_output_type":"console"},"knitr":{"opts_chunk":{"message":false,"warning":false,"code-fold":false,"include":true,"collapse":true,"eval":true,"fig.show":"hold"}},"toc-location":"right","sidebar":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}