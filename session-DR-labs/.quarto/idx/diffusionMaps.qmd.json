{"title":"diffusionMaps","markdown":{"yaml":{"title":"diffusionMaps","format":{"html":{"toc":true,"toc-location":"right","number-sections":true,"code-fold":false,"sidebar":true}},"editor":"visual","editor_options":{"chunk_output_type":"console"},"knitr":{"opts_chunk":{"message":false,"warning":false,"code-fold":false,"include":true,"collapse":true,"eval":true,"fig.show":"hold"}}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\nIn this tutorial, we explore **Diffusion Maps** and **PHATE**, two powerful nonlinear dimensionality reduction techniques that excel in capturing the geometric structure of complex datasets, particularly in life sciences. They are especially useful for continuous processes, such as cell development or biological trajectories.\n\n## Diffusion Maps\n\n-   **Diffusion maps** leverage the relationship between heat diffusion and a random walk Markov chain on the dataset. The basic idea is that in a random walk, you're more likely to step to a nearby point than one farther away.\n-   The connectivity between two points is defined as the probability of transitioning from one to the other in one step, typically via a **kernel function**. This defines the local geometry and leads to construction of a **transition matrix (M)** for the Markov chain.\n-   Raising **M** to higher powers simulates a diffusion process over time, revealing the geometric structure at increasing scales. The parameter *t* acts as both a time and scale parameter.\n-   The **diffusion distance** between two points at time *t* reflects their similarity based on how many short paths connect them. It is robust to noise and integrates all indirect connections—making it suitable for inference tasks.\n-   This distance can be computed from the **eigenvectors and eigenvalues** of the diffusion matrix.\n-   By keeping only the first *k* eigenvectors and their eigenvalues (due to spectral decay), the data is embedded in a *k*-dimensional space. The resulting **diffusion map** is a nonlinear embedding where Euclidean distances approximate diffusion distances, capturing the intrinsic geometry of the original data.\n\n## Data\n\n```{r}\n#| fig.width: 12\n#| fig.height: 10\n\nlibrary(tidyverse)\nlibrary(mixOmics)\n\n# load data\ndata(breast.TCGA)\nx <- rbind(breast.TCGA$data.train$mirna,breast.TCGA$data.test$mirna)\nlabels <-c(breast.TCGA$data.train$subtype,breast.TCGA$data.test$subtype)\n\n# scale data\nx_scaled <- scale(x)\n\n# preview data\n# data dimensions\nx |> dim() |> print () # dimensions of the data matrix (samples x features)\nlabels |> as.factor() |> summary() # samples per group\n\n# box plots \npar(mfrow=c(2,1))\nboxplot(t(x), main=\"distribution per sample\", las=2, cex.axis=0.7, col=rainbow(10), outline=FALSE, cex.main=0.8)\nboxplot(x, main=\"distribution per miRNA\", las=2, cex.axis=0.7, col=rainbow(10), outline=FALSE, cex.main=0.8)\n\n```\n\n```{r}\n# perform PCA\n# perform PCA\npca <- prcomp(x, center=TRUE, scale.=FALSE)\neigs <- pca$sdev^2\nvar_exp <- eigs / sum(eigs)\n\nres_pca <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], PC3=pca$x[,3], PC4=pca$x[,4], PC5=pca$x[,5]) |>\n    rownames_to_column(\"sample\") |> \n    as_tibble() \n\nres_pca_loadings <- pca$rotation\n\n# show PCA scores plots\nres_pca |>\n    ggplot(aes(x=PC1, y=PC2, color=labels)) +\n    geom_point() +\n    labs(title=\"PCA of miRNA data\", x=\"PC1\", y=\"PC2\") +\n    xlab(paste(\"PC1 (Var: \", round(var_exp[1] * 100, 2), \"%)\")) +\n    ylab(paste(\"PC2 (Var: \", round(var_exp[2] * 100, 2), \"%)\")) +\n    theme_minimal() +\n    scale_color_manual(values=c(\"Basal\"=\"#FF0000\", \"Her2\"=\"#00FF00\", \"LumA\"=\"#0000FF\")) +\n    theme(legend.title=element_blank())\n\n# show top 10 loadings along PC1\nres_pca_loadings |> \n    as.data.frame() |> \n    rownames_to_column(\"miRNA\") |> \n    arrange(desc(abs(PC1))) |> \n    head(10) |> \n    ggplot(aes(x=reorder(miRNA, PC1), y=PC1)) +\n    geom_bar(stat=\"identity\", fill=\"steelblue\") +\n    coord_flip() +\n    labs(title=\"Top 10 miRNAs contributing to PC1\", x=\"miRNA\", y=\"Loading\") +\n    theme_minimal()\n\n```\n\n\n## Run diffusionMap\n\n```{r}\nlibrary(destiny) # main package for diffusion maps\n\ndm <- DiffusionMap(data = x_scaled, sigma = \"local\")  # adaptive kernel width\n\n# Key parameters\n# - sigma: \tDiffusion scale parameter of the Gaussian kernel\n# - k: \tNumber of neighbors\n# - n_eigs: Number of diffusion components to calculate\n# - density.norm: Density normalization (helps manifold discovery)\n\ndf_dm <- data.frame(\n  DC1 = eigenvectors(dm)[, 1],\n  DC2 = eigenvectors(dm)[, 2],\n  Subtype = labels\n)\n\n# Visualize First Two Diffusion Components\nggplot(df_dm, aes(x = DC1, y = DC2, color = Subtype)) +\n  geom_point(size = 2) +\n  theme_minimal() +\n  labs(title = \"Diffusion Map of miRNA Data\")\n\n#  Explore Diffusion Pseudotime (Optional)\ndf_dm$Pseudotime <- eigenvectors(dm)[, 1]\n\nggplot(df_dm, aes(x = DC1, y = DC2, color = Pseudotime)) +\n  geom_point(size = 2) +\n  scale_color_viridis_c() +\n  theme_minimal() +\n  labs(title = \"Diffusion Pseudotime\", color = \"Pseudotime\")\n\n```\n\n## Exercise\n\n```{r}\n#| include: false\n#| eval: false\n\nset.seed(123)\n\n# Parameters\nn_cells <- 100\nn_genes <- 20\npseudotime <- seq(0, 1, length.out = n_cells)\n\n# Simulated gene programs\ngene1 <- sin(pi * pseudotime) + rnorm(n_cells, 0, 0.1)\ngene2 <- pseudotime + rnorm(n_cells, 0, 0.1)\ngene3 <- 1 - pseudotime + rnorm(n_cells, 0, 0.1)\n\n# Noise genes\nnoise <- matrix(rnorm(n_cells * (n_genes - 3), 0, 1), nrow = n_cells)\n\n# Combine all genes into a list\nall_genes <- vector(\"list\", n_genes)\nsignal_genes <- list(gene1, gene2, gene3)\n\n# Random positions to insert signal genes\nsignal_positions <- sample(1:n_genes, 3)\n\n# Fill all positions\nsignal_counter <- 1\nfor (i in 1:n_genes) {\n  if (i %in% signal_positions) {\n    all_genes[[i]] <- signal_genes[[signal_counter]]\n    signal_counter <- signal_counter + 1\n  } else {\n    all_genes[[i]] <- noise[, 1]\n    noise <- noise[, -1, drop = FALSE]\n  }\n}\n\n# Create data frame\nexpr_data <- as.data.frame(all_genes)\ncolnames(expr_data) <- paste0(\"Gene\", 1:n_genes)\n\n# Track which are the signal genes\nsignal_gene_names <- paste0(\"Gene\", signal_positions)\nsignal_gene_names\n\nwrite_csv(expr_data, \"diffmap-sim-gene-expr.csv\")\n\n```\n\nWe have simulated a dataset with 100 cells and 20 genes, where 3 genes have a signal related to pseudotime. Load the data `diffmap-sim-gene-expr.csv` and run a diffusion map analysis. Could you identify the genes that correlate with the first diffusion component?\n\nHint: \n\n- there should be one gene highly positively correlated with the first diffusion component and one negatively correlated.\n\n**Example code**\n\n```{r}\nlibrary(tidyverse)\nlibrary(destiny)\nlibrary(viridis)\n\n# Load the simulated data\nexpr_data <- read_csv(\"data/diffmap-sim-gene-expr.csv\")\n\n# scale data\nx <- scale(expr_data)\n\n# Run Diffusion Map\ndm <- DiffusionMap(data = x, sigma = \"local\")  # adaptive kernel width\n\ndf_dm <- data.frame(\n  DC1 = eigenvectors(dm)[, 1],\n  DC2 = eigenvectors(dm)[, 2]\n)\n\n# Visualize First Two Diffusion Components\nggplot(df_dm, aes(x = DC1, y = DC2)) +\n  geom_point(size = 2) +\n  theme_minimal() +\n  labs(title = \"Diffusion Map of miRNA Data\")\n\n#  Explore Diffusion Pseudotime (Optional)\ndf_dm$Pseudotime <- eigenvectors(dm)[, 1]\n\nggplot(df_dm, aes(x = DC1, y = DC2, color = Pseudotime)) +\n  geom_point(size = 2) +\n  scale_color_viridis_c() +\n  theme_minimal() +\n  labs(title = \"Diffusion Pseudotime\", color = \"Pseudotime\")\n```\n\n```{r}\n# find genes positively and negatively correlated with DC1\ndc1 <- eigenvectors(dm)[, 1]\n\n# Correlate each gene with DC1\ncor_with_dc1 <- apply(x, 2, function(g) cor(g, dc1))\n\n# top genes positively correlated with DC1\ncor_with_dc1_sorted <- sort(cor_with_dc1, decreasing = TRUE)\nhead(cor_with_dc1_sorted, 5)\n\n# color code UMAP by the expression of the correlated genes\nlibrary(viridis)\n\nggplot(df_dm, aes(x = DC1, y = DC2, color = expr_data$Gene5, size = expr_data$Gene5)) +\n  geom_point(alpha = 0.9) +\n  scale_color_viridis_c(option = \"plasma\", name = \"Expression\") +\n  scale_size(range = c(1, 4), guide = \"none\") +\n  theme_minimal() +\n  labs(\n    title = \"Diffusion Map Colored by Gene Expression\",\n    x = \"DC1\", y = \"DC2\"\n  )\n\n# top genes negatively correlated with DC1\ncor_with_dc1_sorted <- sort(cor_with_dc1, decreasing = FALSE)\nhead(cor_with_dc1_sorted, 5)\n\n# color code UMAP by the expression of the correlated genes\nggplot(df_dm, aes(x = DC1, y = DC2, color = expr_data$Gene18, size = expr_data$Gene18)) +\n  geom_point(alpha = 0.9) +\n  scale_color_viridis_c(option = \"plasma\", name = \"Expression\") +\n  scale_size(range = c(1, 4), guide = \"none\") +\n  theme_minimal() +\n  labs(\n    title = \"Diffusion Map Colored by Gene Expression\",\n    x = \"DC1\", y = \"DC2\"\n  )\n\n```\n\n## Additional resources\n\nPHATE (Potential of Heat-diffusion for Affinity-based Transition Embedding) aims to capture both local and global nonlinear structure by using an information-geometric distance derived from a heat-diffusion process. PHATE builds on diffusion maps by modeling data as a diffusion process but introduces key innovations like automatic selection of diffusion time and a log-transformed “potential distance” to better preserve both local and global structure. Unlike diffusion maps, which use eigenvectors for embedding, PHATE applies non-metric multidimensional scaling for improved visualization of trajectories and branching structures\n\n-   [PHATE R Bone Marrow Tutorial R](http://htmlpreview.github.io/?https://github.com/KrishnaswamyLab/phateR/blob/master/inst/examples/bonemarrow_tutorial.html)\n\n-   [PHATE Python Tutorial](https://nbviewer.org/github/KrishnaswamyLab/PHATE/blob/main/Python/tutorial/EmbryoidBody.ipynb)\n","srcMarkdownNoYaml":"\n\n## Introduction\n\nIn this tutorial, we explore **Diffusion Maps** and **PHATE**, two powerful nonlinear dimensionality reduction techniques that excel in capturing the geometric structure of complex datasets, particularly in life sciences. They are especially useful for continuous processes, such as cell development or biological trajectories.\n\n## Diffusion Maps\n\n-   **Diffusion maps** leverage the relationship between heat diffusion and a random walk Markov chain on the dataset. The basic idea is that in a random walk, you're more likely to step to a nearby point than one farther away.\n-   The connectivity between two points is defined as the probability of transitioning from one to the other in one step, typically via a **kernel function**. This defines the local geometry and leads to construction of a **transition matrix (M)** for the Markov chain.\n-   Raising **M** to higher powers simulates a diffusion process over time, revealing the geometric structure at increasing scales. The parameter *t* acts as both a time and scale parameter.\n-   The **diffusion distance** between two points at time *t* reflects their similarity based on how many short paths connect them. It is robust to noise and integrates all indirect connections—making it suitable for inference tasks.\n-   This distance can be computed from the **eigenvectors and eigenvalues** of the diffusion matrix.\n-   By keeping only the first *k* eigenvectors and their eigenvalues (due to spectral decay), the data is embedded in a *k*-dimensional space. The resulting **diffusion map** is a nonlinear embedding where Euclidean distances approximate diffusion distances, capturing the intrinsic geometry of the original data.\n\n## Data\n\n```{r}\n#| fig.width: 12\n#| fig.height: 10\n\nlibrary(tidyverse)\nlibrary(mixOmics)\n\n# load data\ndata(breast.TCGA)\nx <- rbind(breast.TCGA$data.train$mirna,breast.TCGA$data.test$mirna)\nlabels <-c(breast.TCGA$data.train$subtype,breast.TCGA$data.test$subtype)\n\n# scale data\nx_scaled <- scale(x)\n\n# preview data\n# data dimensions\nx |> dim() |> print () # dimensions of the data matrix (samples x features)\nlabels |> as.factor() |> summary() # samples per group\n\n# box plots \npar(mfrow=c(2,1))\nboxplot(t(x), main=\"distribution per sample\", las=2, cex.axis=0.7, col=rainbow(10), outline=FALSE, cex.main=0.8)\nboxplot(x, main=\"distribution per miRNA\", las=2, cex.axis=0.7, col=rainbow(10), outline=FALSE, cex.main=0.8)\n\n```\n\n```{r}\n# perform PCA\n# perform PCA\npca <- prcomp(x, center=TRUE, scale.=FALSE)\neigs <- pca$sdev^2\nvar_exp <- eigs / sum(eigs)\n\nres_pca <- data.frame(PC1=pca$x[,1], PC2=pca$x[,2], PC3=pca$x[,3], PC4=pca$x[,4], PC5=pca$x[,5]) |>\n    rownames_to_column(\"sample\") |> \n    as_tibble() \n\nres_pca_loadings <- pca$rotation\n\n# show PCA scores plots\nres_pca |>\n    ggplot(aes(x=PC1, y=PC2, color=labels)) +\n    geom_point() +\n    labs(title=\"PCA of miRNA data\", x=\"PC1\", y=\"PC2\") +\n    xlab(paste(\"PC1 (Var: \", round(var_exp[1] * 100, 2), \"%)\")) +\n    ylab(paste(\"PC2 (Var: \", round(var_exp[2] * 100, 2), \"%)\")) +\n    theme_minimal() +\n    scale_color_manual(values=c(\"Basal\"=\"#FF0000\", \"Her2\"=\"#00FF00\", \"LumA\"=\"#0000FF\")) +\n    theme(legend.title=element_blank())\n\n# show top 10 loadings along PC1\nres_pca_loadings |> \n    as.data.frame() |> \n    rownames_to_column(\"miRNA\") |> \n    arrange(desc(abs(PC1))) |> \n    head(10) |> \n    ggplot(aes(x=reorder(miRNA, PC1), y=PC1)) +\n    geom_bar(stat=\"identity\", fill=\"steelblue\") +\n    coord_flip() +\n    labs(title=\"Top 10 miRNAs contributing to PC1\", x=\"miRNA\", y=\"Loading\") +\n    theme_minimal()\n\n```\n\n\n## Run diffusionMap\n\n```{r}\nlibrary(destiny) # main package for diffusion maps\n\ndm <- DiffusionMap(data = x_scaled, sigma = \"local\")  # adaptive kernel width\n\n# Key parameters\n# - sigma: \tDiffusion scale parameter of the Gaussian kernel\n# - k: \tNumber of neighbors\n# - n_eigs: Number of diffusion components to calculate\n# - density.norm: Density normalization (helps manifold discovery)\n\ndf_dm <- data.frame(\n  DC1 = eigenvectors(dm)[, 1],\n  DC2 = eigenvectors(dm)[, 2],\n  Subtype = labels\n)\n\n# Visualize First Two Diffusion Components\nggplot(df_dm, aes(x = DC1, y = DC2, color = Subtype)) +\n  geom_point(size = 2) +\n  theme_minimal() +\n  labs(title = \"Diffusion Map of miRNA Data\")\n\n#  Explore Diffusion Pseudotime (Optional)\ndf_dm$Pseudotime <- eigenvectors(dm)[, 1]\n\nggplot(df_dm, aes(x = DC1, y = DC2, color = Pseudotime)) +\n  geom_point(size = 2) +\n  scale_color_viridis_c() +\n  theme_minimal() +\n  labs(title = \"Diffusion Pseudotime\", color = \"Pseudotime\")\n\n```\n\n## Exercise\n\n```{r}\n#| include: false\n#| eval: false\n\nset.seed(123)\n\n# Parameters\nn_cells <- 100\nn_genes <- 20\npseudotime <- seq(0, 1, length.out = n_cells)\n\n# Simulated gene programs\ngene1 <- sin(pi * pseudotime) + rnorm(n_cells, 0, 0.1)\ngene2 <- pseudotime + rnorm(n_cells, 0, 0.1)\ngene3 <- 1 - pseudotime + rnorm(n_cells, 0, 0.1)\n\n# Noise genes\nnoise <- matrix(rnorm(n_cells * (n_genes - 3), 0, 1), nrow = n_cells)\n\n# Combine all genes into a list\nall_genes <- vector(\"list\", n_genes)\nsignal_genes <- list(gene1, gene2, gene3)\n\n# Random positions to insert signal genes\nsignal_positions <- sample(1:n_genes, 3)\n\n# Fill all positions\nsignal_counter <- 1\nfor (i in 1:n_genes) {\n  if (i %in% signal_positions) {\n    all_genes[[i]] <- signal_genes[[signal_counter]]\n    signal_counter <- signal_counter + 1\n  } else {\n    all_genes[[i]] <- noise[, 1]\n    noise <- noise[, -1, drop = FALSE]\n  }\n}\n\n# Create data frame\nexpr_data <- as.data.frame(all_genes)\ncolnames(expr_data) <- paste0(\"Gene\", 1:n_genes)\n\n# Track which are the signal genes\nsignal_gene_names <- paste0(\"Gene\", signal_positions)\nsignal_gene_names\n\nwrite_csv(expr_data, \"diffmap-sim-gene-expr.csv\")\n\n```\n\nWe have simulated a dataset with 100 cells and 20 genes, where 3 genes have a signal related to pseudotime. Load the data `diffmap-sim-gene-expr.csv` and run a diffusion map analysis. Could you identify the genes that correlate with the first diffusion component?\n\nHint: \n\n- there should be one gene highly positively correlated with the first diffusion component and one negatively correlated.\n\n**Example code**\n\n```{r}\nlibrary(tidyverse)\nlibrary(destiny)\nlibrary(viridis)\n\n# Load the simulated data\nexpr_data <- read_csv(\"data/diffmap-sim-gene-expr.csv\")\n\n# scale data\nx <- scale(expr_data)\n\n# Run Diffusion Map\ndm <- DiffusionMap(data = x, sigma = \"local\")  # adaptive kernel width\n\ndf_dm <- data.frame(\n  DC1 = eigenvectors(dm)[, 1],\n  DC2 = eigenvectors(dm)[, 2]\n)\n\n# Visualize First Two Diffusion Components\nggplot(df_dm, aes(x = DC1, y = DC2)) +\n  geom_point(size = 2) +\n  theme_minimal() +\n  labs(title = \"Diffusion Map of miRNA Data\")\n\n#  Explore Diffusion Pseudotime (Optional)\ndf_dm$Pseudotime <- eigenvectors(dm)[, 1]\n\nggplot(df_dm, aes(x = DC1, y = DC2, color = Pseudotime)) +\n  geom_point(size = 2) +\n  scale_color_viridis_c() +\n  theme_minimal() +\n  labs(title = \"Diffusion Pseudotime\", color = \"Pseudotime\")\n```\n\n```{r}\n# find genes positively and negatively correlated with DC1\ndc1 <- eigenvectors(dm)[, 1]\n\n# Correlate each gene with DC1\ncor_with_dc1 <- apply(x, 2, function(g) cor(g, dc1))\n\n# top genes positively correlated with DC1\ncor_with_dc1_sorted <- sort(cor_with_dc1, decreasing = TRUE)\nhead(cor_with_dc1_sorted, 5)\n\n# color code UMAP by the expression of the correlated genes\nlibrary(viridis)\n\nggplot(df_dm, aes(x = DC1, y = DC2, color = expr_data$Gene5, size = expr_data$Gene5)) +\n  geom_point(alpha = 0.9) +\n  scale_color_viridis_c(option = \"plasma\", name = \"Expression\") +\n  scale_size(range = c(1, 4), guide = \"none\") +\n  theme_minimal() +\n  labs(\n    title = \"Diffusion Map Colored by Gene Expression\",\n    x = \"DC1\", y = \"DC2\"\n  )\n\n# top genes negatively correlated with DC1\ncor_with_dc1_sorted <- sort(cor_with_dc1, decreasing = FALSE)\nhead(cor_with_dc1_sorted, 5)\n\n# color code UMAP by the expression of the correlated genes\nggplot(df_dm, aes(x = DC1, y = DC2, color = expr_data$Gene18, size = expr_data$Gene18)) +\n  geom_point(alpha = 0.9) +\n  scale_color_viridis_c(option = \"plasma\", name = \"Expression\") +\n  scale_size(range = c(1, 4), guide = \"none\") +\n  theme_minimal() +\n  labs(\n    title = \"Diffusion Map Colored by Gene Expression\",\n    x = \"DC1\", y = \"DC2\"\n  )\n\n```\n\n## Additional resources\n\nPHATE (Potential of Heat-diffusion for Affinity-based Transition Embedding) aims to capture both local and global nonlinear structure by using an information-geometric distance derived from a heat-diffusion process. PHATE builds on diffusion maps by modeling data as a diffusion process but introduces key innovations like automatic selection of diffusion time and a log-transformed “potential distance” to better preserve both local and global structure. Unlike diffusion maps, which use eigenvectors for embedding, PHATE applies non-metric multidimensional scaling for improved visualization of trajectories and branching structures\n\n-   [PHATE R Bone Marrow Tutorial R](http://htmlpreview.github.io/?https://github.com/KrishnaswamyLab/phateR/blob/master/inst/examples/bonemarrow_tutorial.html)\n\n-   [PHATE Python Tutorial](https://nbviewer.org/github/KrishnaswamyLab/PHATE/blob/main/Python/tutorial/EmbryoidBody.ipynb)\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":true,"output-file":"diffusionMaps.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.36","bibliography":["references.bib"],"theme":"spacebar","mermaid":{"theme":"forest"},"title":"diffusionMaps","editor":"visual","editor_options":{"chunk_output_type":"console"},"knitr":{"opts_chunk":{"message":false,"warning":false,"code-fold":false,"include":true,"collapse":true,"eval":true,"fig.show":"hold"}},"toc-location":"right","sidebar":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}